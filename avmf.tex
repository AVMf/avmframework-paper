\let\oldvec\vec % avoid ams math vector error
\documentclass{llncs}
\let\vec\oldvec % avoid ams math vector error

% needed for algorithms
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{amsmath}
% for algorithms
\newcommand{\mf}{\mathit{mf}}

\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{bookmark}
\usepackage{xspace}

\newcommand{\AVM}{Alternating Variable Method\xspace}
\newcommand{\longname}{AVM Framework\xspace}
\newcommand{\name}{AVM\hspace{-1pt}$f$\xspace}
\newcommand{\repourl}{\url{https://github.com/AVMf/avmf}\xspace}
\newcommand{\gitclone}{{\tt git clone https://github.com/AVMf/avmf.git}\xspace}
\newcommand{\inlineheading}[1]{\vspace{1mm} \noindent {\bf #1.}}
\newcommand{\codescalefactor}{0.7}
\newcommand{\snippet}[1]{
        \vspace{-1ex}
        \begin{center}
                \scalebox{\codescalefactor}{
                        \begin{tabular}{|l|}
                        \hline
                        \input{snippets/#1}
                        \hline
                        \end{tabular}
                }
        \end{center}
        \vspace{-1ex}
}
\newcommand{\ips}{IPS}
\newcommand{\gs}{GS}
\newcommand{\ls}{LS}

\newcommand{\AppliesAll}{\Comment{$\{\textrm{\ips}, \textrm{\gs}, \textrm{\ls}\}$}}
\newcommand{\AppliesIPS}{\Comment{$\{\textrm{\ips}\}$}}
\newcommand{\AppliesGS}{\Comment{$\{\textrm{\gs}\}$}}
\newcommand{\AppliesLS}{\Comment{$\{\textrm{\ls}\}$}}
\newcommand{\AppliesGSLS}{\Comment{$\{\textrm{\gs}, \textrm{\ls}\}$}}

\newcommand{\pagerule}{\noindent \rule{\textwidth}{.5pt}}

\begin{document}

\title{\texorpdfstring{\name: An\:Open-Source\:Framework\:and\\$\!$Implementation\:of\:the\:Alternating\:Variable\:Method\vspace{-.5em}}{}}

%\author{Phil McMinn\inst{1} \and Gregory M. Kapfhammer\inst{2} \and Dirk Sudholt\inst{1} \and Sonal Mahajan\inst{3} \and William G.J. Halfond\inst{3}}

%\institute{University of Sheffield, UK \and Allegheny College, USA \and University of Southern California, USA}

% aim: get author block to fit in this space (or less)
\author{
        Authors and institutions\\
        suppressed for double-blind review
        \vspace{-1em}
}
\institute{}

\maketitle

\begin{abstract}
The {\it \AVM} (AVM) has been shown to be a particularly fast and effective local search technique for %SBSE.
search-based software engineering.
%, particularly test data generation.
%
Recent developments to the AVM have generalized the types of representations it can optimize and have provably improved its runtime for certain types of objective function landscape. Until now, however, there has been no publicly-available code implementation of these algorithms. This paper introduces \name, an object-oriented Java framework that provides such an implementation. \name is ready for download and configuration for use in a wide variety of SBSE projects.\vspace{-1ex}
\end{abstract}

\vspace{-1em}
\section{Introduction}
\vspace{-1ex}
The {\it \AVM} (AVM) is a local search method that was first proposed for an SBSE problem by Bogdan Korel in 1990~\cite{Korel1990}
%as an adaptation of so-called ``direct'' search methods \cite{Gill1974,Glass1965}
for generating \mbox{numerical} software test data.
% The AVM is an adaptation of so-called direct search methods \cite{Gill1974,Glass1965} to the test data generation problem.
% In particular, the AVM that did not make assumptions about the branching constraints of the program --- for example, their linearity and continuity.
Despite the application of supposedly more robust, global search techniques to this problem (e.g., Genetic Algorithms), the AVM has stood the test of time. In 2007, Harman and McMinn~\cite{Harman2007} reported its effectiveness and efficiency for a series of C programs, and combined it with a GA to provide a ``best of'' Memetic Algorithm approach~\cite{Harman2010}. It has since been used to generate test suites for Java programs~\cite{%Fraser2013,
Fraser2015b}, having been implemented into the {\sc EvoSuite} tool; generate rows of data for testing databases~\cite{Kapfhammer2013,McMinn2015} with the {\it SchemaAnalyst} tool; and combined with dynamic symbolic execution in Microsoft's Pex tool \cite{Lakhotia2010}.
The AVM has since found application to problems outside of test data generation, for example
%% SEE EMAIL FROM SHAUKAT ALI (27/04/16) FOR MORE DETAILS OF THESE:
%
decision ordering for engineering software product lines~\cite{Yue2016}, % T. Yue, S. Ali, H. Lu and K. Nie. Search-based Decision Ordering to Facilitate Product Line Engineering of Cyber-Physical System In Internatonal Conference on Model-Driven Engineering and Software Development., 2016.
%
balancing workload in requirements assignment~\cite{Yue2014}, % T. Yue and S. Ali. Applying Search Algorithms for Optimizing Stakeholders Familiarity and Balancing Workload in Requirements Assignment In ACM Genetic and Evolutionary Computation Conference (GECCO). New York, USA: ACM, 2014.
%
reliability-redundancy-allocation problems~\cite{Qiu2016}, % Xiang Qiu, Shaukat Ali, Tao Yue, and Li Zhang, Reliability-Redundancy-Location Allocation with Maximum Reliability and Minimum Cost Using Search Techniques, Accepted for a publication in Information and Software Technology (IST) Journal, 2016
%
as well as test case selection~\cite{Pradhan2016} and prioritization~\cite{Arrieta2016}. % A. ARRIETA, S. WANG, G. SAGARDUI AND L. ETXEBERRIA. Test Case Prioritization of Configurable Cyber-Physical Systems with Weight-Based Search Algorithms. In Genetic and Evolutionary Computation Conference (GECCO)., 2016.

Since Korel's original paper in 1990, the AVM algorithm has been extended and improved for problems in SBSE: it can now handle a wider range of variable types, including fixed-point numbers~\cite{Harman2007} and strings~\cite{McMinn2015}, and can incorporate new strategies that are proven to speed up the search for certain common types of objective function landscape
\cite{%Kempka2013,
Kempka2015}.

The AVM is therefore capable of handling a variety of search representations and locating solutions to SBSE problems in a very efficient manner. Nevertheless, to incorporate it into an SBSE project, an SBSE researcher has previously had to understand the different variants of algorithm and then produce a faithful implementation of it --- a potentially time-consuming and error prone task. To address this problem, we have developed \name, an open-source object-oriented framework that implements variants of the AVM and its representations, and is available for download and deployment in SBSE projects. \name~is fully documented and comes with a series of examples demonstrating its usage.

%This paper is organized as follows: first we introduce the basic form of the AVM, as originally proposed by Korel~\cite{Korel1990} (Section~\ref{sec:basic}). We then survey some of the improvements subsequently made (Section~\ref{sec:improvements}). Section~\ref{sec:avmf} then introduces \name, our AVM framework, describing how it is implemented and how it is intended to be used. Finally, Section~\ref{sec:conclusions} concludes with proposals as to future projects to which the framework could be applied.

% Before introducing \name, we briefly review the basic form of the AVM algorithm and recent extensions.

\section{The AVM and Recent Improvements to the Algorithm}
% something about how the algorithm starts, randomly or with initial values?
\vspace{-1em}
\inlineheading{The original AVM} The AVM optimizes a vector $\vec{x} = (x_1, \dots, x_{len})$ according to some objective function by taking each variable $\vec{x}_i, 0 \leq i \leq len$ of the vector in turn and subjecting it to an individual search process. The original AVM used a variable search process subsequently named
% TODO: This would be a good place to cite the GECCO version of this paper, if space, as it was the first to name IPS
``Iterated Pattern Search'' (IPS)~\cite{Kempka2015}, shown by lines 1--7 of Figure~\ref{fig:alg}. The initial part of this algorithm involves making an increase and decrease of $1$ to the value of the variable (lines 2--3), referred to as {\it exploratory moves}. If either exploratory move leads to an improvement in the objective value for the complete vector, a positive or negative ``direction'' is established for making further {\it pattern moves} (lines 4--6). Pattern moves of increasing size continue to be made while the objective value improves. When a pattern move does not improve on the objective value compared to the previous move, the search has likely overshot the optimum, due to a pattern move that was larger than the difference between the current value of $\vec{x}_i$ and the optimal value. When this occurs, IPS loops back to the exploratory move process to re-establish a new direction. If exploratory moves do not lead to an improvement in objective value, IPS terminates and hands back control to the main loop, and the consideration of the next variable in the vector.

When all variables in the vector have been considered, the AVM wraps back to the first. When a cycle of all variables has completed without any improvement in the objective function, the AVM is lodged in a local optimum. At this point the search process can be restarted with a new (typically random) series of vector values.
The AVM continues in this fashion until resources are exhausted (e.g., a maximum number of objective function evaluations or restarts have been expended, or a time limit has expired), or, the best outcome is attained --- the optimal target vector is discovered. (For simplicity, these different termination criteria are not included as part of the algorithm definitions in Figure~\ref{fig:alg}.)

\begin{figure}[t!]
\pagerule

\begin{algorithmic}[1]
        \scriptsize

        \While{$\textbf{true}$} \AppliesIPS
                \State$\textbf{if }obj(x-1)\geq obj(x)\textbf{ and }obj(x+1)\geq obj(x)\textbf{ return }x$ \AppliesAll
                \State$\textbf{if }obj(x-1)<obj(x+1)\textbf{ then let }k:=-1\textbf{ else let }k:=1$ \AppliesAll
                \While{$obj(x+k)<obj(x)$} \AppliesAll
                        \State$\textbf{let }x:=x+k\text{, }k:=2k$ \AppliesAll
                \EndWhile \AppliesAll
        \EndWhile \AppliesIPS\vspace{1mm}

        \State$\textbf{let }\ell:=\min(x-k/2,x+k)\text{, }r:=\max(x-k/2,x+k)$ \AppliesGSLS\vspace{1mm}

        \While{$\ell<r$} \AppliesGS
                \If{$obj(\lfloor(\ell+r)/2\rfloor)<obj(\lfloor(\ell+r)/2\rfloor+1)$} \AppliesGS
                        \State$r:=\lfloor(\ell+r)/2\rfloor$ \AppliesGS
                \Else \AppliesGS
                        \State$\ell:=\lfloor(\ell+r)/2\rfloor+1$ \AppliesGS
                \EndIf \AppliesGS
        \EndWhile \AppliesGS\vspace{1mm}

        \State$\textbf{let }n:=\min\{n\mid F_{n}\geq r-l+2\}$ \AppliesLS
        \While{$n>3$} \AppliesLS
                \If{$\ell+F_{n-1}-1\leq r\textbf{ and }obj(\ell+F_{n-2}-1)\geq obj(\ell+F_{n-1}-1)$} \AppliesLS
                        \State$\textbf{let }\ell:=\ell+F_{n-2}$ \AppliesLS
                \EndIf \AppliesLS
                \State$\textbf{let }n:=n-1$ \AppliesLS
        \EndWhile \AppliesLS\vspace{1mm}

        \State$x:=\ell$ \AppliesGSLS
\end{algorithmic}
\vspace{-1em}
\pagerule
\vspace{-1em}
\caption{\label{fig:alg}IPS, LS, GS search algorithms for the AVM for a variable $x \in D$. $obj(x)$
%denotes the problem-specific
is the objective function, %which is
computed for the complete vector $\vec{x}$ currently being optimized by the AVM, where $\vec{x}_i := x, 0 \leq i \leq len$. $F$ is the Fibonacci sequence starting from $F_0\,=\,0$. Each line is annotated to show the algorithm(s) to which it belongs.}
\vspace{-1em}
\end{figure}

\inlineheading{New Representations}
Korel only demonstrated the original AVM with integer variables~\cite{Korel1990}. Harman and McMinn~\cite{Harman2007} extended this initial definition by allowing each variable to be specified with a set number of decimal places $p$, allowing fixed-point numbers to be handled. Exploratory moves correspond to the smallest possible increments and decrements of the variable (i.e., $\pm10^{-p}$). McMinn et al.~\cite{McMinn2015} allowed string variables to be represented by the approach. A string variable is essentially a sub-vector, whose elements are characters that are individually manipulated by the local search routine. The length of this sub-vector is allowed to vary through a special sequence of moves that increase and decrease its size, allowing for the optimization of variable-length strings.

\inlineheading{New Variable Search Algorithms}
Kempka et al.~\cite{Kempka2015} proposed two new variable searches for the AVM, as shown in Figure~\ref{fig:alg}. Kempka et al.\ proved that these search techniques are more efficient than IPS for unimodal objective function landscapes. ``Geometric Search'' (GS) begins by performing exploratory moves followed by pattern moves like IPS. Unlike IPS, however, it does not iterate after overshooting the optimum. Instead it uses past moves to  ``bracket'' the upper and lower limits of the variable in which the optimum must lie, performing a binary search to finally locate it (lines 8--15 of Figure~\ref{fig:alg}). ``Lattice Search'' (LS) is a slightly faster alternative to GS (provided the objection function landscape is, again, unimodal). LS is similar to GS, except that after bracketing the optimum, it converges upon it through moves that increase the value of $\vec{x}$ from the lower end by adding Fibonacci numbers (lines 16--22 of the figure).

\vspace{-1em}
\section{The \longname (\name)}
\vspace{-1ex}
\label{sec:avmf}
The \longname (\name) implements the both AVM algorithm and the subsequent enhancements to the original version proposed by Korel. The framework has been implemented with the aim of making the core algorithms as clear as possible, thereby closely matching the algorithmic definitions of Figure~\ref{fig:alg}, while still adhering to well-accepted principles of good object-oriented design.

\name is publicly available at \repourl as a Git repository for inclusion in SBSE projects where the AVM may be the core search algorithm, or, a component of a more complex technique (e.g., a Memetic Algorithm) involving calls to algorithms in the framework. Or, the code can simply be lifted from the repository and adapted to a project as developers see fit.

\name provides a framework of Java classes, which we now describe in detail, that enable the algorithms to be easily used in SBSE projects. Each aspect of the framework is practically demonstrated by the source code of a series of examples in the repository, which are introduced at the end of this section.

\begin{sloppypar}
\inlineheading{Configuring an AVM search} The primary class is the {\tt AVM} class in the root ({\tt org.avmframework}) package. In order to construct an {\tt AVM} instance, the developer must supply an instance of one of the variable search methods; {\tt IteratedPatternSearch}, {\tt GeometricSearch} or {\tt LatticeSearch}, which reside in the {\tt localsearch} package. The developer must also construct the {\tt AVM} instance using a {\tt TerminationPolicy} parameter, an object that decides when the AVM should terminate if a solution cannot found. Options include a maximum number of objective function evaluations, a maximum number of restarts, or a time limit. Finally, constructing the {\tt AVM} instance further requires two objects of type {\tt Initializer} that are used to initialize variable vector values at the start of the search and re-initialize them on a restart. Default values may be used that can be specified for each variable, or random values can be chosen (through instances of either {\tt DefaultInitializer} or {\tt RandomInitializer} respectively, classes that reside in the {\tt initializer} package). To support the generation of random numbers, \name requires a {\tt RandomGenerator} from the {\tt org.apache.commons} library that provides an implementation of the Mersenne Twister algorithm.
\end{sloppypar}

\begin{sloppypar}
In order to initiate a search process, the {\tt search} method of the {\tt AVM} instance must be invoked with an instance of a {\tt Vector} class and an {\tt ObjectiveFunction} respectively. The {\tt Vector} class describes the representation of the problem,
%to the AVM,
(i.e., the types of variables in the vector to be optimized), while the {\tt ObjectiveFunction} class describes how instances of those vectors should be rewarded with objective values during the search.
%We now describe these aspects in further detail.
\end{sloppypar}

\begin{sloppypar}
\inlineheading{Representation} In order to configure the search representation, an instance of the {\tt Vector} class (in the root package) must be created, and variables added to it through the {\tt addVariable} method, which accepts an instance of a {\tt Variable}. {\tt Variable} is an abstract class, so an instance of one its concrete subclasses must be provided (i.e., one of {\tt IntegerVariable}, {\tt FixedPointVariable}, {\tt CharacterVariable} or {\tt StringVariable}). Each variable must be constructed with information such as its minimum or maximum value (maximum length for strings), number of decimal places for fixed-point variables, and a ``default'' initial value in the search space (e.g., an empty string or a zero value). These values are used to initialize vector variables when the {\tt DefaultInitializer} is used to providing a starting point for the search, as previously described.
\end{sloppypar}

\begin{sloppypar}
\inlineheading{Objective Function} In contrast to the rest of the framework, which requires configuring instances of existing classes, an objective function is supplied to the search process by overriding the abstract {\tt ObjectiveFunction} of the {\tt objective} package. This involves providing an implementation of the {\tt computeObjectiveValue} method, which takes a {\tt Vector} as a parameter and returns an instance of the abstract {\tt ObjectiveValue} class. Since the AVM only needs to know whether one class has a ``better'' objective value than another, exact numerical values are not needed, and so this class requires the ``{\tt betterThan}'', ``{\tt worseThan}'' and ``{\tt sameAs}'' methods to overridden.
%This is useful for when a problem involves two objectives that must be optimized, but with some precedence (e.g., the classical ``approach level'' and ``branch distance'' components of the fitness function for structural test data generation \cite{}), avoiding the need for a normalization function to combine the values. % Arcuri, Poulding GECCO reference.
However, the {\tt objective} package also supplies the concrete {\tt NumericalObjectiveValue} class for returning higher-is-better or lower-is-better numerical objective values as needed.
\end{sloppypar}

\begin{sloppypar}
\inlineheading{Reporting} The {\tt search} method of the {\tt AVM} class returns an instance of the {\tt Monitor} class, which can be used to find out interesting statistics regarding the search. These include the best vector found by the search, its objective value, the number of objective function evaluations that took place, the number of restarts that took place, and the amount of time that the search took (in milliseconds). The {\tt Monitor} class can also report the number of {\it unique} objective function evaluations. The objective function can make optional usage of a cache that maps previously ``seen'' vectors to objective values, avoiding the need to perform potentially costly re-evaluations.
% (a feature that is turned on by default).
%Using this cache helps make the search process more efficient by not repeating potentially expensive objective function evaluations for vectors that have already been considered during the search.
\end{sloppypar}

\inlineheading{Examples} \name comes with three small examples demonstrating its use. (Instructions on how to compile and run these examples are available in the project's {\tt README.md} file, in the root directory of the project's repository.) The first, {\tt Quadratic} demonstrates the use of the AVM to solve a quadratic equation by finding one of its roots. {\tt AllZeros} demonstrates the optimization of an array of integers to zero values from arbitrary random values, while {\tt String} optimizes a string value from an initially random string to a specified target.
%``{\tt \AVM}''. The examples can be configured with a command line parameter to use IPS, Geometric or Lattice search as the local search method.

Each example makes use of its own problem-specific fitness function that can be seen as part of its code definition. The example below is taken from the {\tt Quadratic} class, where the constants {\tt A}, {\tt B} and {\tt C} correspond to the co-efficients of the equation (in the example {\tt A}\,{\tt =}\,{\tt 4}, {\tt B}\,{\tt =}\,{\tt 10} and {\tt C}\,{\tt =}\,{\tt 6}). The function obtains the value of {\tt x} from the (single variable) vector, and computes the value of {\tt y}. The objective value is then assigned as the distance between {\tt y} and zero, since intuitively, the closer the value of {\tt y} to zero, the closer the search is to finding one of the roots of the equation.

\snippet{objective-fn}

The following is the output of the search process, showing how the AVM search correctly found one of the roots, $-1.5$ (re-running the search from different starting positions leads to the other root, $-1$, being found):

\snippet{search-output}

\vspace{-1em}
\section{Conclusions}
\vspace{-1em}
\label{sec:conclusions}
This paper introduced \name, an open source implementation of the AVM and framework for its use in SBSE projects. Possible future applications of the AVM include the following:

\inlineheading{Automatically Generating Readable Test Data}
Generating {\it readable} test cases that humans can easily understand has been of interest to researchers in search-based testing of late (e.g., rewarding inputs that obtain a high score from a language model \cite{Afshan2013}). More readable values were requested by participants of a recent study evaluating test generation tools \cite{Fraser2013b}. Given that the AVM is local search, the technique could be used to start with examples of human generated inputs and adapt them to new coverage targets without necessarily losing the qualities of the original data.

\inlineheading{Automatically Determining Optimal Software Configuration Values}
Highly configurable pieces of software, such as the GCC compiler, that may be tunable through search techniques such as the AVM. In large spaces of parameters, the AVM is well suited to quickly discovering which particular variables are relevant to the problem through its exploratory move phase, and then proceeding to determining their optimal values. Again, as a local search technique, the AVM is also well suited to taking an existing known-good human solution and improving upon it.

\inlineheading{Automated Bug-Fixing}
Bugs can occur as a result of errors when programming constants and settings files, and as such the AVM could be used as a technique for searching for appropriate values that could potentially form the basis of a ``fix''. Through its exploratory move phase, the AVM is well-suited to quickly determining which constants are relevant to the fix, by performing a quick sweep of small changes through the values involved, and seeing how the resulting fitness values are affected.

%% Commented out for double blind review
%\inlineheading{Acknowledgment}
%We thank Joseph Kempka for an initial implementation of Geometric and Lattice search that we used to test our own version against.

% \vspace{-1em}

% References
\bibliographystyle{splncs03}

%% Uncomment and remove the following to regenerate the references
%\bibliography{refs}


%% pasted in from avmf.bbl:

\begin{thebibliography}{10}
\providecommand{\url}[1]{\texttt{#1}}
\providecommand{\urlprefix}{URL }

% Manually inserted
\scriptsize

\bibitem{Afshan2013}
Afshan, S., McMinn, P., Stevenson, M.: Evolving readable string test inputs
    using a natural language model to reduce human oracle cost. In: ICST (2013)

\bibitem{Arrieta2016}
Arrieta, A., Wang, S., Sagardui, G., Etxeberria, L.: Test case prioritization
    of configurable cyber-physical systems with weight-based search algorithms.
    In: GECCO (2016)

\bibitem{Fraser2015b}
Fraser, G., Arcuri, A., McMinn, P.: A memetic algorithm for whole test suite
    generation. JSS  (2015)

\bibitem{Fraser2013b}
Fraser, G., Staats, M., McMinn, P., Arcuri, A., Padberg, F.: Does automated
    white-box test generation really help software testers? In: ISSTA (2013)

\bibitem{Harman2007}
Harman, M., McMinn, P.: A theoretical and empirical analysis of evolutionary
    testing and hill climbing for structural test data generation. In: ISSTA
    (2007)

\bibitem{Harman2010}
Harman, M., McMinn, P.: A theoretical and empirical study of search based
    testing: Local, global and hybrid search. IEEE TSE  (2010)

\bibitem{Kapfhammer2013}
Kapfhammer, G.M., McMinn, P., Wright, C.J.: Search-based testing of relational
    schema integrity constraints across multiple database management systems. In:
    ICST (2013)

\bibitem{Kempka2015}
Kempka, J., McMinn, P., Sudholt, D.: Design and analysis of different
    alternating variable searches for search-based software testing. TCS  (2015)

\bibitem{Korel1990}
Korel, B.: Automated software test data generation. IEEE TSE  (1990)

\bibitem{Lakhotia2010}
Lakhotia, K., Tillmann, N., Harman, M., Halleux, J.: {FloPSy} --- search-based
    floating point constraint solving for symbolic execution. In: ICTSS (2010)

\bibitem{McMinn2015}
McMinn, P., Wright, C.J., Kapfhammer, G.M.: The effectiveness of test coverage
    criteria for relational database schema integrity constraints. ACM TOSEM
    (2015)

\bibitem{Pradhan2016}
Pradhan, D., Wang, S., Ali, S., Yue, T.: Search-based cost-effective test case
    selection for manual execution within time budget: An empirical study. In:
    GECCO (2016)

\bibitem{Qiu2016}
Qiu, X., Ali, S., Yue, T., Zhang, L.: Reliability-redundancy-location
    allocation with maximum reliability and minimum cost using search techniques.
    IST  (2016)

\bibitem{Yue2014}
Yue, T., Ali., S.: Applying search algorithms for optimizing stakeholders
    familiarity and balancing workload in requirements assignment. In: GECCO
    (2014)

\bibitem{Yue2016}
Yue, T., Ali, S., Lu, H., Nie., K.: Search-based decision ordering to
    facilitate product line engineering of cyber-physical system. In: MODELSWARD
    (2016)

\end{thebibliography}


\end{document}
